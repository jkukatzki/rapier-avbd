Weiter zum Inhalt
Chatverlauf

Du:
what language is cannonJS written in orginally? is it plain js instead of wasm?
ChatGPT:
Yep â€” Cannon.js was originally written in plain JavaScript, not WebAssembly.

Specifically:

It was created by Stefan Hedman around 2013â€“2014, entirely in vanilla ES5 JavaScript, with no TypeScript, no wasm, no C/C++ transpilation involved.

It was designed to be a pure JavaScript physics engine for 3D simulations, inspired by Bullet and ODE, but written from scratch for the browser.

It uses straightforward math and vector classes implemented in JS (no SIMD, no native bindings).

Later forks and rewrites evolved differently:

cannon-es â†’ modern ES6 module rewrite (still pure JS).

cannon-wasm â†’ experimental port compiled from Cannon.js â†’ TypeScript â†’ AssemblyScript â†’ WebAssembly, but thatâ€™s not the original.

So to summarize:
âœ… Original Cannon.js â†’ Plain JavaScript (ES5)
âš™ï¸ Later cannon-es â†’ Modern JavaScript (ES6 modules)
ğŸ§ª cannon-wasm â†’ WebAssembly port (not the original)

Would you like me to show a comparison between the JS math operations in Cannon.js and how theyâ€™d look in a WASM-based engine (like Rapier)?

Du:
yeah that sounds interesting, please do that.
ChatGPT:
Perfect â€” letâ€™s break this down systematically so you can see and feel the difference between how Cannon.js models physics in plain JS and how Rapier (Rust/WASM) or any WASM-backed physics engine does it under the hood.

ğŸ§© 1. Cannon.js (original, pure JS)
Cannon.js defines its math and physics stack in plain JavaScript classes â€” everything runs on the JS heap.

Example:

// cannon.js (simplified)
class Vec3 {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }

  cross(v, target = new Vec3()) {
    const x = this.y * v.z - this.z * v.y;
    const y = this.z * v.x - this.x * v.z;
    const z = this.x * v.y - this.y * v.x;
    target.x = x;
    target.y = y;
    target.z = z;
    return target;
  }

  scale(s, target = new Vec3()) {
    target.x = this.x * s;
    target.y = this.y * s;
    target.z = this.z * s;
    return target;
  }
}

// Using it:
const force = new Vec3(0, 10, 0);
const velocity = new Vec3(1, 0, 0);
const torque = velocity.cross(force);  // plain JS math ops
ğŸ§  Characteristics:

Everything is dynamic and GC-managed.

Vector math is done by explicit JS arithmetic.

No SIMD or type enforcement.

Easy to inspect, patch, and debug â€” but slow for large simulations.

âš™ï¸ 2. Rapier (Rust â†’ WebAssembly)
Rapier, written in Rust, compiles into WebAssembly and exposes a JS API that calls into WASM memory.

Example (using rapier3d):

import RAPIER from "@dimforge/rapier3d-compat";

await RAPIER.init();

const world = new RAPIER.World({ x: 0, y: -9.81, z: 0 });
const rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(0, 10, 0);
const rigidBody = world.createRigidBody(rigidBodyDesc);
const collider = RAPIER.ColliderDesc.ball(1);
world.createCollider(collider, rigidBody);

for (let i = 0; i < 60; i++) {
  world.step();
  const pos = rigidBody.translation();
  console.log(pos.x, pos.y, pos.z);
}
ğŸ§  What actually happens under the hood:

The JS bindings call into WASM memory (Uint8Array / Float64Array view).

The real physics math runs inside compiled Rust code.

Vectors are typed arrays in linear memory.

GC overhead is almost zero â€” memory is manually managed.

Uses SIMD instructions and spatial partitioning (BVH, islands) optimized at compile time.

If you peek at the Rust source, the math looks like this:

#[derive(Copy, Clone)]
pub struct Vector3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl Vector3 {
    pub fn cross(&self, other: &Vector3) -> Vector3 {
        Vector3 {
            x: self.y * other.z - self.z * other.y,
            y: self.z * other.x - self.x * other.z,
            z: self.x * other.y - self.y * other.x,
        }
    }
}
ğŸš€ Performance and Design Contrast
Aspect	Cannon.js	Rapier (WASM)
Language	ES5 JavaScript	Rust compiled to WebAssembly
Memory	JS heap + GC	Linear memory, manual alloc
SIMD support	âŒ No (manual loops)	âœ… Yes (native)
Threading	âŒ Single-threaded	âœ… Can use Web Workers / WASM threads
Debuggability	âœ… Very high	âš ï¸ Limited (opaque memory)
Runtime overhead	ğŸ¢ High (dynamic objects)	âš¡ Very low (native speed)
Data structures	JS classes	Rust structs, compact layout
Safety	âœ… JS runtime safe	âœ… Rust safe, WASM sandboxed
ğŸ§® Example Comparison: Collision Response
Cannon.js:

if (contact.penetrationDepth > 0) {
  const correction = contact.normal.scale(contact.penetrationDepth * 0.5);
  bodyA.position.vsub(correction, bodyA.position);
  bodyB.position.vadd(correction, bodyB.position);
}
Rapier (Rust, conceptually):

if contact.penetration_depth > 0.0 {
    let correction = contact.normal * contact.penetration_depth * 0.5;
    body_a.position -= correction;
    body_b.position += correction;
}
JS â†’ executes arithmetic on heap objects
WASM â†’ executes in CPU registers (SIMD-friendly, much faster)

ğŸ’¡ Summary
Engine	Written in	Executed as	Typical Use
Cannon.js	Plain JavaScript (ES5)	Interpreted / JIT	Lightweight browser demos, games
cannon-es	Modern JS (ES6 modules)	JIT optimized	Clean modern alternative
Rapier	Rust â†’ WebAssembly	Compiled binary	High-performance real-time physics
Ammo.js	C++ â†’ Emscripten (Bullet)	WebAssembly	Legacy Bullet port
If youâ€™d like, I can show a side-by-side profiling trace (how JS vs WASM looks in Chromeâ€™s performance tab for the same 100-body drop test). Would you like me to generate that visualization conceptually?

Du:
can you take a look at this paper?
https://graphics.cs.utah.edu/research/projects/avbd/Augmented_VBD-SIGGRAPH25.pdf

how could I improve rapier to use this technology?
ChatGPT:

Nachgedacht fÃ¼r 41s
Short answer: yesâ€”thereâ€™s a concrete path to bring AVBD (Augmented Vertex Block Descent)â€“style solving into Rapier. Below is a practical, â€œhow-to-wire-itâ€ plan that maps the paperâ€™s ideas onto Rapierâ€™s architecture, plus a minimal Rust sketch to get you started.

What AVBD adds (in a nutshell)
It solves implicit Euler as a global energy minimization but does it with vertex/body-local 3Ã—3 (particles) or 6Ã—6 (rigid) updates (VBD).

It augments constraints via an Augmented Lagrangian: each constraint keeps a dual variable Î» and a dynamic stiffness k, letting you treat hard constraints (âˆ stiffness) robustly and handle huge stiffness ratios (contacts, stacking, joints) with few iterations, warm-starting across frames. 
graphics.cs.utah.edu
+1

Key equations from the RTL paper you linked (SIGGRAPH Real-Time Live! â€™25) show:

Per-vertex/body update solves Háµ¢ Î”xáµ¢ = fáµ¢ (3Ã—3 or 6Ã—6).

Augmented energy per constraint uses kâ½â¿â¾ and Î»â½â¿â¾, updated each iteration; warm-starting uses Î±, Î², Î³ with suggested values Î±=0.95, Î²=10, Î³=0.99. 
graphics.cs.utah.edu

Where this fits in Rapier
Rapierâ€™s pipeline â‰ˆ Broad phase â†’ Narrow phase â†’ Constraint solver (sequential impulses / NGS). You can add an alternative solver backend that:

Uses Rapierâ€™s existing contact generation & joint graph,

Replaces the impulse solve with AVBDâ€™s local Newton updates + augmented Lagrangian.

Think of each rigid body as a â€œvertexâ€ with xáµ¢ = [páµ¢, qáµ¢] (6 DOF); each constraint (contact, joint, spring) contributes to E(x) via Câ±¼(x), âˆ‡Câ±¼, and local Hessian blocks. The solve iterates Gaussâ€“Seidel-style over bodies/blocks.

Implementation roadmap
1) New solver feature flag
Add a solver_avbd feature and a SolverBackend::AVBD. Wire it where impulse_joints / contact_constraints are currently solved.

2) Data structures
Per-constraint: store

lambda: f32 (or f64),

k: f32 (dynamic stiffness),

function closures or trait impls to compute C(x), gradient w.r.t. body i (3/6 DOF), and Hessian blocks.

Per-body: cached mass & inertia (already in Rapier), exposed as 3Ã—3 or 6Ã—6 blocks.

Create a trait:

pub trait AvbdConstraint {
    fn eval_c(&self, x: &BodyState) -> f32;                   // C_j(x)
    fn grad_i(&self, i: BodyId, x: &BodyState) -> [f32; 6];   // âˆ‚C/âˆ‚x_i (6 for rigid)
    fn hess_i(&self, i: BodyId, x: &BodyState) -> [[f32;6];6];// âˆ‚Â²E/âˆ‚x_iÂ² contribution
    // contact/joint params, friction directions, etc.
}
3) Build the AVBD per-iteration linear system
For a body i, compute:

fáµ¢ = âˆ’(1/Î”tÂ²) Máµ¢ (xáµ¢ âˆ’ yáµ¢) + Î£â±¼ fáµ¢â±¼, with fáµ¢â±¼ = âˆ’âˆ‚Eâ±¼/âˆ‚xáµ¢.

Háµ¢ = (1/Î”tÂ²) Máµ¢ + Î£â±¼ Háµ¢â±¼, where Háµ¢â±¼ = âˆ‚Â²Eâ±¼/âˆ‚xáµ¢Â².
Then solve Háµ¢ Î”xáµ¢ = fáµ¢, update pose:

páµ¢ â† páµ¢ + Î”páµ¢
qáµ¢ â† normalize(qáµ¢ + 0.5 * (0, Î”Ï‰áµ¢) âŠ— qáµ¢)
(Exactly as in the RTL doc.) 
graphics.cs.utah.edu

4) Augmented Lagrangian for constraints
Represent each constraint energy per iteration n as:

Eâ±¼(x) = 0.5 * kâ±¼â½â¿â¾ * Câ±¼(x)Â² + Î»â±¼â½â¿â¾ * Câ±¼(x)
After a sweep:

Î»â±¼â½â¿+1â¾ = Î»â±¼â½â¿â¾ + kâ±¼â½â¿â¾ * Câ±¼(x)           // dual ascent
kâ±¼â½â¿+1â¾ = min(Î² * kâ±¼â½â¿â¾, k_max)             // grow stiffness
Warm start each frame with:

kâ±¼â½â°â¾ = max(Î³ * kâ±¼áµ—, k_start)
Î»â±¼â½â°â¾ = Î± * Î³ * Î»â±¼áµ—
Use the paperâ€™s suggested Î±=0.95, Î²=10, Î³=0.99 initially. 
graphics.cs.utah.edu

Contacts & friction. Model normal contact as hard constraint (gap â‰¥ 0 â†’ complementarity approximated via AL; in practice you clamp or use piecewise C(x) for penetration). Friction can be handled with tangential constraints using friction cone projection inside the AVBD update (prox step) or via smooth energy approximations; the AVBD demos emphasize that stacking/friction behave robustly with this AL formulation. 
graphics.cs.utah.edu

5) Parallelization strategy
VBD is highly parallelizable: group bodies into independent sets (graph coloring on the constraint graph) and update sets in parallel. You can start single-threaded (Gaussâ€“Seidel), then move to batch Jacobi per color to exploit Rayon threads; later, explore GPU compute for the 6Ã—6 solves if desired. 
graphics.cs.utah.edu

6) Integration layering
Keep collision detection (Parry) unchanged.

Build AVBD constraints from Rapierâ€™s contacts (normal + friction dirs) and joint definitions.

Provide AvbdSolverParams { iters, alpha, beta, gamma, k_start, k_max }.

Add warm-start caches for k and Î» across frames.

7) Minimal Rust sketch (body update)
fn avbd_sweep(
    dt: f32,
    bodies: &mut [RigidBodyState],
    constraints: &mut [Box<dyn AvbdConstraint>],
    params: &AvbdSolverParams,
) {
    // Build inertial positions y = x_t + dt*v_t + dt^2*a_ext
    // (Here: abbreviated; Rapier already has integrators.)
    for _iter in 0..params.iters {
        // Optionally color bodies for parallel updates
        for i in 0..bodies.len() {
            let (f_i, h_i) = accumulate_f_h_for_body(i, dt, bodies, constraints);
            // Solve 6x6: H_i * dx_i = f_i (Cholesky or LDLáµ€)
            let dx_i = solve6x6(&h_i, &f_i);
            bodies[i].apply_delta(dx_i);
        }
        // Augmented Lagrangian updates per constraint
        for c in constraints.iter_mut() {
            let cval = c.eval_c(&BodyState { bodies });
            c.lambda += c.k * cval;
            c.k = (c.k * params.beta).min(params.k_max);
        }
    }
}
8) Testing & tuning
Start with joints only (hinge, fixed), then contacts without friction, then Coulomb friction.

Compare scenes where Rapierâ€™s current solver struggles (tall stacks, extreme mass ratios) and measure iterations to converge, penetration error, CPU time.

Try the paperâ€™s constants first (Î±, Î², Î³), then tune. 
graphics.cs.utah.edu

9) Optional: GPU path later
The authors showcase GPU timings (RTX 4090: big stacks in ~3.5 ms solver, ~9.8 ms incl. collision). If you want parity, port the inner per-body 6Ã—6 solves to wgpu compute with conflict-free batching. Keep CPU as default. 
graphics.cs.utah.edu

References you can lean on
Project page + paper blurb: overview and motivation; highlights AL for hard constraints and robustness to stiffness ratios. 
graphics.cs.utah.edu

SIGGRAPH RTL paper (2-page, equations & params): concrete formulas (Háµ¢ Î”xáµ¢ = fáµ¢, AL updates, warm start Î±, Î², Î³). 
graphics.cs.utah.edu

SIGGRAPH RTL entry / DOI: supplemental context & claims of stability/throughput. 
SIGGRAPH 2025
+1

If you want, I can draft a tiny Rapier fork diff that stubs AvbdConstraint for hinge and non-penetration and replaces the solver loop behind a feature flagâ€”so you can A/B it against the current sequential-impulse solver on your favorite â€œhigh stacksâ€ scene.

Du:
yes please, also can I use this commercially? is the paper to be used in any game?
ChatGPT:
Cool â€” letâ€™s break this into two parts:

Stubbed Rapier diff / skeleton code (for AVBD)

Legal / licensing / commercial use of the AVBD paper / method in games

1. Stub Rapier diff / skeleton for AVBD integration
Hereâ€™s how you might start a fork or patch of Rapier (Rust) to integrate AVBD behind a feature flag. This is just scaffolding to give you a sense of how it would slot in; real-world production code would require careful handling of spatial data, constraint types, memory layout, etc.

A. New types & traits
In rapier/src/solver/avbd.rs (new file):

use crate::dynamics::{RigidBodyHandle, RigidBodySet};
use crate::dynamics::narrow_phase::ContactConstraint;
use crate::math::{Real, Vector, Isometry, AngularInertia};
use crate::geometry::ColliderHandle;

pub struct AvbdConstraint {
    // references to bodies, contact / joint data
    body1: RigidBodyHandle,
    body2: RigidBodyHandle,
    // dual variable Î» and stiffness k
    lambda: Real,
    k: Real,
    // any cached Jacobian, contact normal, etc.
}

pub struct AvbdSolverParams {
    pub iterations: usize,
    pub alpha: Real,
    pub beta: Real,
    pub gamma: Real,
    pub k_start: Real,
    pub k_max: Real,
}

impl AvbdConstraint {
    pub fn new_contact(/* args: contact data */) -> Self {
        Self {
            body1,
            body2,
            lambda: 0.0,
            k: /* init later per warm start */,
            /* etc */
        }
    }

    /// Evaluate the constraint function C(x)
    pub fn eval_c(&self, bodies: &RigidBodySet) -> Real {
        // e.g. gap distance (penetration neg), or hinge angle error, etc.
        0.0
    }

    /// Compute gradient âˆ‚C/âˆ‚x_i (for each body) as 6-vector
    pub fn grad(&self, bodies: &RigidBodySet, body: RigidBodyHandle) -> [Real; 6] {
        [0.0; 6]
    }

    /// Compute Hessian block âˆ‚Â²E/âˆ‚x_iÂ² (6Ã—6) for this constraint on a given body
    pub fn hess_block(&self, bodies: &RigidBodySet, body: RigidBodyHandle) -> [[Real; 6]; 6] {
        [[0.0; 6]; 6]
    }
}
In rapier/src/solver/mod.rs, add:

pub enum SolverBackend {
    Impulse,
    Avbd,
    // maybe others
}
Modify struct IntegrationParameters or solver config to include backend: SolverBackend.

B. Solver invocation
In the solver module (where Rapier currently runs sequential impulses or NGS), replace or branch:

match params.backend {
    SolverBackend::Impulse => {
        self.solve_with_impulses(/* existing code */);
    }
    SolverBackend::Avbd => {
        self.solve_with_avbd(bodies, constraints, params);
    }
}
Implement solve_with_avbd in rapier/src/solver/avbd_solver.rs (or same file):

fn solve_with_avbd(
    &mut self,
    bodies: &mut RigidBodySet,
    constraints: &mut [AvbdConstraint],
    params: &AvbdSolverParams,
    dt: Real,
) {
    // 1. Warm start: for each constraint, set initial k, Î»
    for c in constraints.iter_mut() {
        c.k = (params.gamma * c.k).max(params.k_start);
        c.lambda = params.alpha * params.gamma * c.lambda;
    }

    for _ in 0..params.iterations {
        // Gaussâ€“Seidel sweep over bodies (or in some coloring order)
        for i in 0..bodies.len() {
            // compute f_i and H_i
            let (mut f_i, mut H_i) = init_inertial_terms(bodies, i, dt);
            // accumulate per-constraint contributions
            for c in constraints.iter() {
                if c.body1 == i || c.body2 == i {
                    let grad = c.grad(bodies, i);
                    let hess = c.hess_block(bodies, i);
                    // f_i += âˆ’âˆ‚E / âˆ‚x_i = âˆ’(k * C + Î») * grad
                    let cval = c.eval_c(bodies);
                    let factor = c.k * cval + c.lambda;
                    for d in 0..6 {
                        f_i[d] -= factor * grad[d];
                    }
                    // H_i += k * grad âŠ— grad + approximate second derivative
                    for r in 0..6 {
                        for c_ in 0..6 {
                            H_i[r][c_] += c.k * grad[r] * grad[c_] + hess[r][c_];
                        }
                    }
                }
            }
            // Solve H_i Î”x_i = f_i (6x6 linear solve)
            let dx_i = solve6x6(&H_i, &f_i);
            // Apply to body (position + orientation / rotation)
            bodies[i].apply_delta(dx_i, dt);
        }

        // After updating all bodies, update dual variables
        for c in constraints.iter_mut() {
            let cval = c.eval_c(bodies);
            c.lambda += c.k * cval;
            c.k = (c.k * params.beta).min(params.k_max);
        }
    }
}
Youâ€™ll need helpers:

init_inertial_terms builds 
f
i
=
âˆ’
M
/
Î”
t
2
(
x
i
âˆ’
y
i
)
f 
i
â€‹
 =âˆ’M/Î”t 
2
 (x 
i
â€‹
 âˆ’y 
i
â€‹
 ) and 
H
i
=
M
/
Î”
t
2
H 
i
â€‹
 =M/Î”t 
2
 

solve6x6 â€” either hand-coded small symmetric solver, or use a lightweight linear algebra crate

apply_delta on a RigidBodyState to update position & orientation (quaternion or rotation vector) as the paper describes

Building constraints list from Rapierâ€™s contact manifold + joint manifolds before solver run

C. Hooking into Rapierâ€™s pipeline
In the phase after collision detection / contact manifold generation, map each contact or joint into an AvbdConstraint (with its initial geometry, Jacobians, etc.).

Pass that vector into solve_with_avbd.

After solve, extract new body positions/orientations, velocities (if needed), cache k and Î» for next frame.

D. Feature gating & safety
Wrap AVBD code under a crate feature (e.g. #[cfg(feature = "avbd")]) so you donâ€™t bloat default builds

Provide fallbacks if a constraint type isnâ€™t yet supported by AVBD (e.g. default back to impulse solver)

Add debug asserts to check that Hâ‚áµ¢â‚ is positive definite or well-conditioned (avoid singular systems)

Instrument for comparisons vs the impulse solver (error, speed)

This skeleton gives you a starting point. It omits many practical complexities:

Handling friction (Coulomb cone, projection / clamping)

Contact complementarity (non-penetration constraints are unilateral)

Efficiency: incremental caching of Jacobians, sparsity, coloring/parallel updates

Mixed constraint types (springs, motors, soft bodies)

Stability and numerical tuning

Memory layout to avoid cache thrashing

But it gives you a testable stub to A/B your AVBD solver against Rapierâ€™s existing one.

2. Can you use AVBD in commercial games? What about legal / licensing?
Short answer: almost certainly yes, but with some caveats (you should verify with a lawyer). Let me unpack what is known and what to check.

What the paper itself says about use rights
The Real-Time Live! PDF (the extended abstract) includes a note:

â€œPermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice â€¦ For all other uses, contact the owner/author(s).â€ 
graphics.cs.utah.edu

That clause is standard for the RT Live abstract version. But that does not necessarily reflect the licensing rights for the full paper, method, or code.

This clause suggests the PDF distribution is restricted (for commercial redistribution you'd need permission), but doesnâ€™t necessarily forbid implementing the algorithm. Research papers typically present methods that are assumed to be usable by others, unless thereâ€™s a patent or restrictive license explicitly stated.

Also, the paper is part of the ACM / SIGGRAPH proceedings, which carry copyright, and copies are governed by ACMâ€™s copyright policies. The method or algorithm itself, in many jurisdictions, is not protected by copyright (ideas, algorithms are often not copyrightable, though implementation is). However, patents or code licenses could restrict usage.

What to check / steps
If you intend to use AVBD in a commercial project, do the following:

Check for patents / disclosures

The authors may have filed a patent on â€œAugmented VBDâ€ or related innovations.

Search patent databases under the authorsâ€™ names (Giles, Diaz, Yuksel, etc.) or associated institutions (University of Utah).

If a patent exists, you may need a license to use it commercially.

Check for a code release / license

The project page (AVBD) mentions â€œSource Code for the online demo is available on GitHub.â€ 
graphics.cs.utah.edu

Inspect that repository: what license is the demo code under (MIT, BSD, Apache, etc.)? That matters if you want to use or adapt that code, especially commercially.

Contact authors / institution

For any ambiguous rights (especially commercial use), email the authors or the university tech transfer office.

Ask specifically: â€œIs the AVBD algorithm patented, and what license would you grant for commercial use (game engine, runtime)?â€

Credit & attribution

Even if commercial use is allowed, it's good practice to include attribution in your documentation (e.g. â€œPhysics solver uses Augmented Vertex Block Descent by Giles et al., SIGGRAPH 2025â€).

Some research code licenses require that.

Given the lack of explicit â€œall rights reserved / no commercial useâ€ in the abstract, itâ€™s plausible you can use the algorithm implementation (i.e., in your engine) commercially, provided no patent blocks you. The abstractâ€™s â€œnot for profitâ€ clause applies to copies of the PDF, not necessarily algorithm implementation.

Final verdict (likely scenario)
You can implement AVBD in your engine and ship it commercially, unless a patent is asserted or the code you copy is under a restrictive license.

Using the paper as inspiration (writing your own implementation) is generally acceptable in research & commercial settings.

Using the demoâ€™s reference code: check its license. If MIT / BSD / permissive, then it's safe. If â€œall rights reservedâ€, you'd need permission.

If you like, I can help you examine the GitHub demo code license for AVBD and search for possible patents. Do you want me to do that?

Du:
can you try to break down the new technique and what technique rapier or other physics engines use or lack that don't implement this? whats at the core of the improvement? explain like im five please
ChatGPT:
Perfect â€” this is exactly the right kind of question to ask when youâ€™re trying to really understand what the new technique changes.
Letâ€™s break it down step by step, using the â€œexplain like Iâ€™m fiveâ€ approach first â€” then Iâ€™ll gradually build back up to the technical layer.

ğŸ§  Imagine youâ€™re playing with toy blocks
You have:

Lots of little blocks (the physics bodies),

Some invisible rubber bands and hinges connecting them (the constraints),

And a big hand (the solver) that repeatedly fixes things when blocks interpenetrate or fall apart.

Now, what we care about is how the hand decides where to move each block to make the scene look right after gravity, collisions, and constraints.

âš™ï¸ The Old Way (used in Rapier, Bullet, PhysX, etc.)
Rapier, Bullet, ODE, Box2D â€” they all mostly use something called Sequential Impulses or Projective Gaussâ€“Seidel (PGS).

Think of it like this:

You look at one constraint (say, a contact between two blocks).

You nudge those two blocks a little so they donâ€™t overlap.

Then you move to the next constraint and do the same.

Repeat this a bunch of times.

Each nudge is local and simple â€” â€œpush these two apart just enough.â€
But because every push messes up the next constraint, you have to repeat the process over and over until everything more or less settles.

Itâ€™s fast and simple, but has limitations:

Itâ€™s iterative: needs many passes to converge.

Itâ€™s approximate: stacking ten boxes gets wobbly or squishy.

Itâ€™s bad with very different masses or stiffnesses (light and heavy objects connected together).

It handles contacts and joints separately, not as one unified â€œenergyâ€ problem.

So the â€œold handâ€ just keeps poking at things until it looks okay â€” good enough for games, but not mathematically stable.

ğŸŒŸ The New Way (AVBD: Augmented Vertex Block Descent)
AVBD changes how the solver thinks about the problem.

Instead of saying â€œletâ€™s fix one contact at a time,â€
it says â€œletâ€™s minimize a single big energy function that describes how wrong the world currently is.â€

Every constraint (contact, joint, spring) adds a little â€œenergyâ€ that grows when itâ€™s violated.

Then, AVBD does this:

Breaks the world into small blocks (one per body, or per vertex in a soft body).

Computes how each block contributes to the total â€œenergy.â€

Solves tiny 3Ã—3 (particles) or 6Ã—6 (rigid body) equations per block to move them toward lower energy.

Repeats a few times â€” but each pass reduces the whole worldâ€™s energy together, not constraint-by-constraint.

Now, the â€œAugmentedâ€ part means it keeps a memory (Î», the Lagrange multiplier) of how strongly each constraint was pushing before, and adapts its stiffness (k) automatically so even hard constraints (like â€œthese two blocks can never overlapâ€) stabilize quickly.

In toy-block terms:

Instead of poking one contact at a time, the hand now sees all the strings at once,
pulls them just the right amount,
and remembers how tight each string was last time.

ğŸ§© What Rapier and similar engines lack compared to AVBD
Concept	Rapier (Sequential Impulse)	AVBD
Mathematical form	Local impulse correction	Global energy minimization
Per-constraint stiffness	Hardcoded or simple damping	Adaptive stiffness (k) updated every iteration
Dual variables (Î»)	Usually implicit in impulses	Explicitly tracked and warm-started
Coupling between constraints	Weak (processed one-by-one)	Strong (shared energy surface)
Stability with stacking / stiffness ratios	Poor unless many iterations	Excellent even with few iterations
Friction handling	Separate, iterative	Unified within same optimization step
Parallelization potential	Limited (depends on contact order)	High (per-body blocks are independent)
Convergence property	Approximate	Provably convergent to the constrained minimum (under mild assumptions)
ğŸª„ The Core Idea (why itâ€™s better)
Hereâ€™s the essence of the improvement, boiled down:

Instead of solving constraints as a bunch of little â€œfixesâ€ that fight each other,
AVBD turns them into one big optimization problem â€”
â€œFind the positions of all bodies that make the total constraint energy as small as possible.â€

And it does that efficiently by:

Partitioning the problem per body (so itâ€™s parallel and cache-friendly),

Using the Hessian (second derivatives) to guide movement (so it knows how stiff each connection is),

Adapting constraint stiffness dynamically (so it doesnâ€™t overshoot or lag), and

Remembering past constraint forces (so it starts each frame already close to the solution).

That combination gives fast convergence and robust stacking â€” no jittering towers, no squishy springs, fewer iterations.

ğŸ’¬ A visual metaphor
Old solvers = â€œWhack-a-Moleâ€

You fix one problem, another pops up.

Works okay, but itâ€™s chaotic.

AVBD = â€œMassage the whole blanketâ€

Every push redistributes energy evenly.

The wrinkles smooth out quickly.

The solver â€œremembersâ€ the blanketâ€™s shape next time.

ğŸ§© In technical summary
Level	Classic PGS / Impulse	AVBD
Math form	Solve J Mâ»Â¹ Jáµ€ Î» = b iteratively	Minimize E(x) = Â½ Î£ k CÂ² + Î»C
Update rule	Î» â† clamp(Î» + Î”Î»)	Î» â† Î» + kC, k â† Î²k
Variable space	impulses (Î» only)	positions (x) and multipliers (Î») jointly
Linearization	velocity-level	position-level (better for hard constraints)
Core concept	sequential constraint impulses	block-local Newton minimization
Benefits	simple, real-time	robust, scalable, unified contacts + joints
If you want, I can visualize this with a small schematic â€” like a before/after diagram showing how impulses vs AVBD energy minimization work (using blocks and springs).
Would you like me to make that visual?

Du:
hell yeah let me see a diagram i am curious what you can do visually, chatgpt
ChatGPT:

Bild erstellt
Generiertes Bild
Generiertes Bild
Generiertes Bild



Weitergeben
Du:
eh, i dont know if diffusion is the right call for showing diagrams. still very impressive though!
so are we replacing the entire solver or "hand pulling strings" if we implement this in rapier? what are broad phases btw and how do they relate to our implementation?
ChatGPT:
Excellent questions â€” and that phrasing (â€œhand pulling stringsâ€) is actually perfectly aligned with how physics engines are structured. Letâ€™s unpack it in your metaphorical (but accurate) way:

ğŸ§© 1. Where the "hand" lives in Rapier
Think of the physics simulation loop as a factory assembly line:

Broad phase â€“ â€œWho might be touching?â€

Narrow phase â€“ â€œWhoâ€™s actually touching?â€

Constraint setup â€“ â€œWhat strings or hinges connect them?â€

Solver â€“ â€œNow the hand comes in and moves them until everything fits.â€

Integration â€“ â€œApply gravity, damping, etc. and update positions.â€

Your AVBD implementation would replace step 4, the solver stage â€” the actual â€œhand pulling the strings.â€

The rest of the pipeline (phases 1â€“3 and 5) can stay completely the same.

ğŸ§  2. The role of Broad Phase
Hereâ€™s how to visualize it:

The broad phase is the scout that looks out over all your toys and says:
â€œThose two boxes are far apart â€” ignore them.
These two are close â€” check them more carefully!â€

Itâ€™s all about performance.
Checking every body against every other would be O(nÂ²) â€” too slow.

So the broad phase uses spatial data structures (like AABB trees or sweep grids) to quickly find pairs of objects that might collide.

Rapierâ€™s broad phase implementations include:

SAP (Sweep and Prune) â€” good for sorted linear motion.

QBVH (Quantized Bounding Volume Hierarchy) â€” a tree of bounding boxes.

They produce a list of candidate pairs to check.

Then comes the narrow phase, which tests those pairs precisely (e.g., actual triangle-triangle or convex contact).

âš™ï¸ 3. How AVBD fits in this pipeline
Hereâ€™s the full Rapier-style pipeline, showing where AVBD fits:

[ Broad Phase ]
     â†“
 candidate pairs (A, B)
     â†“
[ Narrow Phase ]
     â†“
 contact manifolds (normals, points, friction)
     â†“
[ Constraint Setup ]
     â†“
 list of constraints (contact, joint, etc.)
     â†“
[ Solver ]
     â†“
  â”œâ”€ Sequential Impulse (default)
  â””â”€ AVBD (your new one)
     â†“
 updated positions / orientations
     â†“
[ Integration ]
So yes â€” if you implement AVBD, youâ€™re replacing only the solver (step 4).
Everything upstream â€” detection, constraint generation â€” still feeds into your solver the same way.

ğŸ’¡ 4. Why we can plug in AVBD easily
Because:

Rapier already organizes its physics constraints into clear structures (contact_constraints, joint_constraints).

These structures give you:

Each bodyâ€™s index,

Jacobians (how constraint affects velocity/position),

Effective mass / inertia tensors,

The constraint error term (C(x) or penetration depth).

Thatâ€™s exactly what AVBD needs as input to compute the energy function per constraint:

E
(
x
)
=
1
2
k
C
2
+
Î»
C
E(x)= 
2
1
â€‹
 kC 
2
 +Î»C
So you can think of AVBD as a drop-in alternative â€œbrainâ€ that just interprets those constraint data differently.

ğŸ” 5. Broad Phase & Solver independence
You can even run the same broad phase regardless of solver type:

Broad phase doesnâ€™t care how you resolve collisions.

It only finds potential pairs for the narrow phase to check.

Meaning:
âœ… You can switch between Sequential Impulse and AVBD with a simple flag
âœ… No change needed to collision detection, shapes, or joint APIs.

ğŸª„ 6. Analogy summary
Part of pipeline	What it does	Toy analogy	Affected by AVBD?
Broad phase	Find who might collide	â€œWhoâ€™s near each other?â€	âŒ
Narrow phase	Find where they collide	â€œMeasure overlap preciselyâ€	âŒ
Constraint setup	Turn contacts into springs/strings	â€œTie rubber bands between touching blocksâ€	âŒ
Solver	Move blocks to reduce error	â€œThe hand pulls all strings correctlyâ€	âœ… (this is your AVBD)
Integration	Apply motion for next frame	â€œLet gravity actâ€	âŒ
So in short:

Youâ€™re not rebuilding Rapier â€”
youâ€™re just teaching its â€œhandâ€ to move more gracefully.

If you want, I can sketch out a conceptual block diagram showing the full Rapier pipeline with where AVBD plugs in (with arrows for data flow). Would you like me to visualize that next (and this time make it more schematic, not diffused)?

Du:
yea do that, also i meant the diffuse image generation, not that it looks diffused. maybe us python or something to generate it?
ChatGPT:

Nachgedacht fÃ¼r 9s
Bild ausgeben
Hereâ€™s a clean schematic showing where AVBD plugs into the pipeline.
Download the diagram

Quick recap:

Broad phase: fast â€œwho might collide?â€ pruning.

Narrow phase: precise contacts for those pairs.

Constraint setup: turn contacts/joints into constraint data.

Solver: this is the only piece you swap â€” choose Sequential Impulse (classic) or AVBD (new).

Integration: advance positions/velocities.

Want a second diagram that zooms into the solver itself (PGS vs. AVBD inner loop)?



Du:
would this still ensure determinism which is a selling point of rapier?
ChatGPT:
Beautifully sharp question â€” and absolutely the right one to ask when modifying a physics engine like Rapier, because determinism is one of the most delicate and prized properties in physics simulation, especially for multiplayer sync or lockstep games.

Letâ€™s unpack this carefully:

ğŸ§­ First: What â€œdeterminismâ€ really means here
In Rapierâ€™s context:

Determinism = given the same inputs (scene setup, frame rate, timestep, order of operations), the engine produces exactly the same outputs bit-for-bit, every run, across all platforms.

So if you record a simulation or run a multiplayer game where all clients apply the same inputs in the same order, everyone stays in perfect sync.

This determinism depends on three things:

Fixed iteration order â€“ the same bodies, constraints, and pairs processed in the same sequence.

Stable floating-point math â€“ identical instruction order, no parallel race conditions, same precision across builds.

Pure logic flow â€“ no randomization, data-dependent traversal, or multi-thread nondeterminism.

Rapierâ€™s current sequential impulse solver is designed with this in mind â€” it runs deterministically as long as you use the same physics parameters and fixed timestep.

ğŸ§© How AVBD affects determinism
Hereâ€™s the nuance:

Property	Sequential Impulse	AVBD (as proposed)
Iteration order	Explicit and serial (constraint list)	Can be explicit (serial) or batched (parallel)
Math operations	Simple multiply/add, few branches	Small 3Ã—3 / 6Ã—6 linear solves (more math ops)
Memory access pattern	Fixed array walk	Still fixed if you donâ€™t shuffle
Parallelization	Optional but often disabled for determinism	Same â€” must run single-threaded or fixed-color order for determinism
So:
âœ… If you implement AVBD as a single-threaded, fixed-order block solver, it can be fully deterministic.
âŒ If you parallelize it aggressively (Jacobi style or graph-coloring), then floating-point accumulation order will differ slightly, and determinism will break.

Even though the result looks the same visually, floating-point differences accumulate over time and can cause divergence in multiplayer lockstep contexts.

ğŸ”¬ Practical determinism checklist for AVBD
To preserve determinism in Rapier while using AVBD:

Iterate bodies and constraints in a fixed, deterministic order.

Sort constraints by (body1_index, body2_index) before each step.

Never use hash maps or unstable iteration orders.

Avoid parallel accumulation of forces or corrections.

Per-body updates should happen strictly one after another.

If you want multi-threading, you can make a â€œdeterministic parallel schedulerâ€ that enforces fixed color order (but thatâ€™s advanced).

Use deterministic math routines for the 6Ã—6 solves.

Prefer pure f32 or f64 with no SIMD vector reductions that vary by platform.

Donâ€™t rely on BLAS / LAPACK â€” implement a tiny inline Gaussian elimination so you control operation order.

No adaptive step-size or tolerance checks that early-break based on magnitude.

Always do a fixed number of AVBD iterations (say, 10).

Disable multi-threaded broad phase if full determinism is required.
(Rapier already has a single-threaded deterministic broad phase mode.)

With these, your AVBD solver would be bitwise deterministic â€” possibly even more stable numerically than the impulse solver for the same scenes, because it converges faster.

ğŸ§  Bonus: Determinism vs. reproducibility vs. stability
Determinism = bit-identical results given same inputs.

Reproducibility = same qualitative results (tower doesnâ€™t fall differently) even if bitwise differs.

Stability = small perturbations donâ€™t explode into chaos.

AVBD is numerically more stable than PGS, but if you donâ€™t lock down execution order, it becomes non-deterministic (though still reproducible in behavior).

So if your game depends on lockstep sync (like RTS or deterministic replays), keep AVBD single-threaded with a fixed iteration order.
If you only care about â€œvisual determinismâ€ (same on one machine but not across CPUs), you can parallelize it.

ğŸª„ TL;DR
Yes, AVBD can remain deterministic in Rapier â€”
you just have to treat it like a delicate instrument:

No random order, no parallel reduction.

Fixed iteration order and math ops.

Use small, self-contained 6Ã—6 solvers you control.

Then itâ€™ll behave just as deterministically as the current solver, with better stacking and stiffness handling.

Would you like me to show what a deterministic AVBD loop would look like in Rust pseudocode (with fixed iteration and no parallelization)?




Keine ausgewÃ¤hltKeine ausgewÃ¤hlt
ChatGPT kann Fehler machen. ÃœberprÃ¼fe wichtige Informationen. Siehe Cookie-Voreinstellungen.
